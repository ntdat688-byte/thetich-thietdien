<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mô phỏng Thể tích - Tâm Đức</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Math.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>

    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
            }
        }
    </script>

    <style>
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #f8fafc; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }

        /* Glassmorphism utility */
        .glass {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        
        /* Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: #4f46e5;
            margin-top: -7px;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }
        input[type=range]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: #cbd5e1;
            border-radius: 2px;
        }
        
        body { overflow: hidden; touch-action: none; }
        
        /* Animation for Floating Buttons */
        .fab-btn {
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .fab-btn:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800 font-sans h-screen flex flex-col md:flex-row overflow-hidden">

    <!-- Sidebar -->
    <aside id="sidebar" class="fixed inset-y-0 left-0 md:relative w-80 h-full glass z-50 transform -translate-x-full md:translate-x-0 transition-all duration-300 flex flex-col border-r border-slate-200 shadow-2xl md:shadow-none md:ml-0">
        
        <!-- Sidebar Header (Simplified) -->
        <div class="p-5 bg-indigo-700 text-white shrink-0 relative flex items-center justify-between">
            <div>
                <h1 class="text-sm font-bold uppercase tracking-wider flex items-center gap-2">
                    <i class="fa-solid fa-sliders"></i> THÔNG SỐ MÔ PHỎNG
                </h1>
            </div>
            
            <!-- Close Button for Mobile -->
            <button id="closeSidebarBtn" class="md:hidden text-white/70 hover:text-white focus:outline-none p-2 rounded-full hover:bg-white/10 transition">
                <i class="fa-solid fa-xmark text-lg"></i>
            </button>
        </div>

        <div class="flex-1 overflow-y-auto p-5 space-y-6 pb-24 md:pb-5">
            
            <!-- Function Input -->
            <div class="space-y-2">
                <label class="block text-xs font-bold text-slate-500 uppercase tracking-wider">Hàm biên / Đáy f(x)</label>
                <div class="relative group">
                    <span class="absolute left-3 top-2.5 text-slate-400 font-serif italic">y =</span>
                    <input type="text" id="functionInput" value="sqrt(4^2 - x^2)" 
                        class="w-full pl-9 pr-3 py-2.5 bg-slate-50 border border-slate-300 rounded-xl focus:ring-2 focus:ring-indigo-500 outline-none transition-all font-mono text-sm text-indigo-700 group-hover:bg-white shadow-sm">
                </div>
                <p class="text-[10px] text-slate-400 mt-1 italic" id="functionHint">Ví dụ: Đáy tròn R=4</p>
                <p id="errorMsg" class="text-red-500 text-xs hidden flex items-center mt-1"><i class="fa-solid fa-circle-exclamation mr-1"></i>Lỗi cú pháp</p>
            </div>

            <!-- Slicing Options -->
            <div id="slicingOptions" class="space-y-4">
                <div class="space-y-2">
                    <label class="block text-xs font-bold text-slate-500 uppercase tracking-wider">Hình dạng Thiết diện</label>
                    <div class="relative">
                        <select id="shapeSelect" class="w-full pl-3 pr-8 py-2.5 bg-slate-50 border border-slate-300 rounded-xl focus:ring-2 focus:ring-indigo-500 text-sm font-medium text-slate-700 outline-none appearance-none cursor-pointer hover:bg-white transition-colors shadow-sm">
                            <option value="equilateral">Tam giác đều</option>
                            <option value="square">Hình vuông</option>
                            <option value="semicircle">Nửa hình tròn</option>
                            <option value="isosceles">Tam giác vuông cân</option>
                        </select>
                        <div class="absolute right-3 top-1/2 -translate-y-1/2 pointer-events-none text-slate-400">
                            <i class="fa-solid fa-chevron-down text-xs"></i>
                        </div>
                    </div>
                </div>
                
                <!-- Slice Position Slider -->
                <div class="space-y-2 bg-indigo-50 p-4 rounded-xl border border-indigo-100 shadow-sm">
                    <label class="block text-[10px] font-bold text-indigo-800 uppercase flex justify-between mb-2">
                        Vị trí cắt (x)
                        <span id="sliceXVal" class="font-mono text-indigo-600 bg-white px-1.5 py-0.5 rounded border border-indigo-100 shadow-sm">0.00</span>
                    </label>
                    <input type="range" id="sliceXSlider" class="w-full accent-indigo-600 cursor-pointer block h-6">
                </div>
            </div>

            <!-- Range Inputs -->
            <div class="space-y-2">
                <label class="block text-xs font-bold text-slate-500 uppercase tracking-wider">Cận tích phân [a, b]</label>
                <div class="grid grid-cols-2 gap-3">
                    <div>
                        <label class="text-[10px] text-slate-400 block mb-1">Start (a)</label>
                        <input type="number" id="startX" value="-4" step="0.1" class="w-full px-3 py-2 bg-slate-50 border border-slate-300 rounded-lg focus:ring-2 focus:ring-indigo-500 font-mono text-sm hover:bg-white transition-colors">
                    </div>
                    <div>
                        <label class="text-[10px] text-slate-400 block mb-1">End (b)</label>
                        <input type="number" id="endX" value="4" step="0.1" class="w-full px-3 py-2 bg-slate-50 border border-slate-300 rounded-lg focus:ring-2 focus:ring-indigo-500 font-mono text-sm hover:bg-white transition-colors">
                    </div>
                </div>
            </div>

            <hr class="border-slate-200">

            <!-- Appearance -->
            <div class="space-y-4">
                <label class="block text-xs font-bold text-slate-500 uppercase tracking-wider">Hiển thị</label>
                
                <div class="flex items-center justify-between p-2 bg-slate-50 rounded-lg border border-slate-200">
                    <span class="text-sm text-slate-700 font-medium">Lưới (Wireframe)</span>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="wireframeCheck" class="sr-only peer" checked>
                        <div class="w-10 h-6 bg-slate-300 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                    </label>
                </div>
                
                <div class="space-y-1">
                    <div class="flex justify-between text-xs text-slate-500"><span>Độ đậm khối</span><span id="opacityVal">30%</span></div>
                    <input type="range" id="opacitySlider" min="0.1" max="1" step="0.05" value="0.3" class="w-full accent-indigo-600 h-6">
                </div>
            </div>
        </div>
    </aside>

    <!-- Main Canvas Area -->
    <main class="flex-1 relative bg-white w-full h-full">
        
        <!-- App Title Overlay (Centered Top) -->
        <div class="absolute top-2 md:top-4 left-0 right-0 flex justify-center z-10 pointer-events-none px-12 md:px-0">
            <div class="glass px-4 py-2 md:px-6 md:py-3 rounded-full shadow-lg border border-indigo-100 bg-white/95">
                <h1 class="text-[10px] md:text-sm font-bold text-indigo-800 uppercase tracking-widest text-center leading-tight">
                    APP HỌC TẬP HỆ THỐNG GIÁO DỤC TÂM ĐỨC
                </h1>
            </div>
        </div>

        <!-- Desktop Sidebar Toggle Button -->
        <button id="desktopToggleBtn" class="absolute top-4 left-4 z-20 bg-white/90 backdrop-blur text-slate-600 hover:text-indigo-600 hover:bg-white p-2.5 rounded-xl shadow-md border border-slate-200 hidden md:flex items-center justify-center transition-all active:scale-95" title="Ẩn/Hiện thanh công cụ">
            <i class="fa-solid fa-bars text-lg"></i>
        </button>

        <div id="canvas-container" class="w-full h-full cursor-move touch-none"></div>
        
        <!-- Legend Overlay (Top Right) -->
        <div class="absolute top-16 md:top-4 right-4 flex flex-col gap-2 items-end pointer-events-none z-10 scale-90 origin-top-right md:scale-100">
            <div class="glass px-3 py-1.5 rounded-lg text-slate-700 shadow-sm border border-slate-200 flex items-center gap-2">
                <div class="w-3 h-3 bg-yellow-400 rounded-sm shadow-sm border border-yellow-500"></div> <span class="text-[10px] font-bold uppercase">Thiết diện S(x)</span>
            </div>
            <div class="glass px-3 py-1.5 rounded-lg text-slate-700 shadow-sm border border-slate-200 flex items-center gap-2">
                <div class="w-3 h-3 bg-red-500 rounded-full"></div> <span class="text-[10px] font-bold uppercase">Trục Ox</span>
            </div>
            <div class="glass px-3 py-1.5 rounded-lg text-slate-700 shadow-sm border border-slate-200 flex items-center gap-2">
                <div class="w-3 h-3 bg-green-500 rounded-full"></div> <span class="text-[10px] font-bold uppercase">Trục Oy</span>
            </div>
             <div class="glass px-3 py-1.5 rounded-lg text-slate-700 shadow-sm border border-slate-200 flex items-center gap-2">
                <div class="w-3 h-3 bg-blue-500 rounded-full"></div> <span class="text-[10px] font-bold uppercase">Trục Oz</span>
            </div>
        </div>

        <!-- Instructions (Bottom Left) -->
        <div class="absolute bottom-24 md:bottom-4 left-4 z-10 pointer-events-none">
             <div class="glass px-3 py-2 rounded-lg border border-slate-200 shadow-sm text-slate-600 text-[10px] md:text-xs font-medium flex gap-3 items-center bg-white/80">
                <span class="flex items-center"><i class="fa-solid fa-rotate mr-1.5 text-indigo-500"></i>Xoay</span>
                <span class="w-px h-3 bg-slate-300"></span>
                <span class="flex items-center"><i class="fa-solid fa-magnifying-glass-plus mr-1.5 text-indigo-500"></i>Zoom</span>
                <span class="w-px h-3 bg-slate-300"></span>
                <span class="flex items-center"><i class="fa-regular fa-hand-paper mr-1.5 text-indigo-500"></i>Kéo</span>
            </div>
        </div>

        <!-- Author Credit (Bottom Right) -->
        <div class="absolute bottom-24 md:bottom-4 right-4 z-10 pointer-events-none">
             <div class="glass px-3 py-2 rounded-lg border border-red-100 shadow-sm bg-white/90">
                <p class="text-[10px] md:text-xs text-red-600 font-bold uppercase tracking-wide">Thiết kế bởi: GV Nguyễn Thành Đạt</p>
            </div>
        </div>

        <!-- Floating Action Buttons (Bottom Center) -->
        <div class="absolute bottom-6 left-0 right-0 flex justify-center items-center gap-4 z-20 pointer-events-none">
            <!-- Container for buttons to receive pointer events -->
            <div class="flex items-center gap-3 p-2 rounded-2xl glass shadow-xl pointer-events-auto border border-white/50 backdrop-blur-xl">
                
                <!-- Toggle Sidebar Button (Mobile) -->
                <button id="fabMenuBtn" class="fab-btn w-10 h-10 md:hidden flex items-center justify-center rounded-xl bg-white text-slate-600 hover:bg-slate-100 hover:text-indigo-600 shadow-sm border border-slate-200" title="Cài đặt">
                    <i class="fa-solid fa-sliders text-lg"></i>
                </button>

                <div class="w-px h-6 bg-slate-300 md:hidden"></div>

                <!-- Play Button -->
                <button id="fabPlayBtn" class="fab-btn h-11 px-6 bg-indigo-600 hover:bg-indigo-700 text-white rounded-xl shadow-md flex items-center gap-2 font-bold text-sm tracking-wide transition-colors">
                    <i class="fa-solid fa-play"></i> <span id="fabPlayText">CHẠY</span>
                </button>

                <!-- Reset Camera Button -->
                <button id="fabResetBtn" class="fab-btn w-11 h-11 bg-white hover:bg-slate-50 text-slate-600 hover:text-indigo-600 rounded-xl shadow-sm border border-slate-200 flex items-center justify-center" title="Góc nhìn chuẩn">
                    <i class="fa-solid fa-video"></i>
                </button>
            </div>
        </div>
    </main>

    <!-- Overlay for Mobile Sidebar -->
    <div id="sidebarOverlay" class="fixed inset-0 bg-slate-900/20 backdrop-blur-sm z-40 hidden transition-opacity"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let meshGroup, axesGroup, lineGroup;
        let isPlaying = false;
        let debounceTimer;
        
        const config = {
            expr: 'sqrt(4^2 - x^2)',
            a: -4, b: 4,
            currentX: -4, 
            sliceShape: 'equilateral',
            segments: 60, 
            opacity: 0.3,
            wireframe: true, 
            color: 0x2563eb 
        };

        const container = document.getElementById('canvas-container');
        const shapeSelect = document.getElementById('shapeSelect');
        const inputFunc = document.getElementById('functionInput');
        const inputA = document.getElementById('startX');
        const inputB = document.getElementById('endX');
        const sliceXSlider = document.getElementById('sliceXSlider');
        const sliceXVal = document.getElementById('sliceXVal');
        const wireframeCheck = document.getElementById('wireframeCheck');
        const opacitySlider = document.getElementById('opacitySlider');
        const opacityVal = document.getElementById('opacityVal');
        
        // Floating Buttons
        const fabPlayBtn = document.getElementById('fabPlayBtn');
        const fabPlayText = document.getElementById('fabPlayText');
        const fabResetBtn = document.getElementById('fabResetBtn');
        const fabMenuBtn = document.getElementById('fabMenuBtn');
        const desktopToggleBtn = document.getElementById('desktopToggleBtn');
        
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff); 
            scene.fog = new THREE.Fog(0xffffff, 30, 100);

            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
            
            // Camera isometric view
            camera.position.set(12, -12, 10); 
            camera.up.set(0, 0, 1);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxDistance = 50;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
            dirLight.position.set(8, -10, 15);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 50;
            dirLight.shadow.bias = -0.001; 
            scene.add(dirLight);
            
            const fillLight = new THREE.DirectionalLight(0xebf8ff, 0.3);
            fillLight.position.set(-5, 0, 5);
            scene.add(fillLight);

            axesGroup = new THREE.Group(); scene.add(axesGroup);
            meshGroup = new THREE.Group(); scene.add(meshGroup);
            lineGroup = new THREE.Group(); scene.add(lineGroup);

            config.currentX = config.a;
            sliceXSlider.value = config.a;
            sliceXVal.innerText = config.a.toFixed(2);

            updateSimulation();
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function onWindowResize() {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // --- MATH HELPERS ---
        function getCurvePoints() {
            try {
                const node = math.parse(config.expr);
                const code = node.compile();
                const points = [];
                const step = (config.b - config.a) / config.segments;
                let maxVal = 0;

                for (let i = 0; i <= config.segments; i++) {
                    const x = config.a + i * step;
                    let y = 0;
                    try { y = code.evaluate({ x: x }); } catch (e) {}
                    if (typeof y === 'object' && y.im) y = 0;
                    if (isNaN(y) || !isFinite(y)) y = 0;
                    points.push({ x: x, y: Math.abs(y) });
                    if (Math.abs(y) > maxVal) maxVal = Math.abs(y);
                }
                
                const rangeDiff = Math.abs(config.b - config.a);
                if (rangeDiff > 0.1) {
                    sliceXSlider.min = config.a;
                    sliceXSlider.max = config.b;
                    sliceXSlider.step = step;
                }
                
                document.getElementById('errorMsg').classList.add('hidden');
                document.getElementById('functionInput').classList.remove('border-red-500', 'text-red-600');
                
                return { points, maxVal, maxDim: Math.max(Math.abs(config.a), Math.abs(config.b), maxVal) };
            } catch (err) {
                document.getElementById('errorMsg').classList.remove('hidden');
                document.getElementById('functionInput').classList.add('border-red-500', 'text-red-600');
                return null;
            }
        }

        function getShapeVertices(x, halfWidth) {
            const w = halfWidth;
            const profile = [];
            
            if (config.sliceShape === 'equilateral') {
                const h = w * Math.sqrt(3);
                profile.push(new THREE.Vector3(x, -w, 0));
                profile.push(new THREE.Vector3(x, w, 0));
                profile.push(new THREE.Vector3(x, 0, h));
            } else if (config.sliceShape === 'square') {
                const s = 2 * w;
                profile.push(new THREE.Vector3(x, -w, 0));
                profile.push(new THREE.Vector3(x, w, 0));
                profile.push(new THREE.Vector3(x, w, s));
                profile.push(new THREE.Vector3(x, -w, s));
            } else if (config.sliceShape === 'semicircle') {
                const segs = 32; 
                for(let i=0; i<=segs; i++) {
                    const ang = (i/segs) * Math.PI;
                    const y = -w * Math.cos(ang);
                    const z = w * Math.sin(ang);
                    profile.push(new THREE.Vector3(x, y, z));
                }
            } else if (config.sliceShape === 'isosceles') {
                profile.push(new THREE.Vector3(x, -w, 0));
                profile.push(new THREE.Vector3(x, w, 0));
                profile.push(new THREE.Vector3(x, -w, 2*w));
            }
            return profile;
        }

        function createSlicedGeometry(allPoints, limitX) {
            const vertices = [];
            const indices = [];
            const activePoints = [];
            
            let i = 0;
            while(i < allPoints.length && allPoints[i].x < limitX) {
                activePoints.push(allPoints[i]);
                i++;
            }

            if (activePoints.length > 0) {
                let y = 0;
                if (i < allPoints.length) {
                    const p1 = allPoints[i-1] || allPoints[0];
                    const p2 = allPoints[i];
                    if (p2.x !== p1.x) {
                        const t = (limitX - p1.x) / (p2.x - p1.x);
                        y = p1.y + (p2.y - p1.y) * t;
                    } else { y = p2.y; }
                } else if (activePoints.length > 0) {
                    y = activePoints[activePoints.length-1].y;
                }
                activePoints.push({ x: limitX, y: y });
            } else if (i < allPoints.length) {
                 const pStart = allPoints[0];
                 activePoints.push(pStart);
                 if(limitX > pStart.x) {
                     const p2 = allPoints[1];
                     if(p2) {
                        const t = (limitX - pStart.x) / (p2.x - pStart.x);
                        const y = pStart.y + (p2.y - pStart.y) * t;
                        activePoints.push({ x: limitX, y: y });
                     }
                 }
            }
            
            const grid = [];
            activePoints.forEach(p => {
                const profile = getShapeVertices(p.x, p.y);
                const rowIndices = [];
                profile.forEach(v => {
                    vertices.push(v.x, v.y, v.z);
                    rowIndices.push((vertices.length/3) - 1);
                });
                grid.push(rowIndices);
            });

            for (let r = 0; r < grid.length - 1; r++) {
                const row1 = grid[r];
                const row2 = grid[r+1];
                for (let c = 0; c < row1.length - 1; c++) {
                    const a = row1[c], b = row2[c], c_v = row2[c+1], d = row1[c+1];
                    indices.push(a, b, d); indices.push(d, b, c_v);
                }
                indices.push(row1[0], row1[row1.length-1], row2[0]);
                indices.push(row2[0], row1[row1.length-1], row2[row2.length-1]);
            }
            
            if(grid.length > 0) {
                const row = grid[0];
                for (let k = 1; k < row.length - 1; k++) {
                     indices.push(row[0], row[k], row[k+1]);
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();
            return geometry;
        }

        function createCurrentSliceMesh(x, y) {
            const profile = getShapeVertices(x, y);
            if (profile.length < 3) return null;
            const vertices = [];
            const indices = [];
            profile.forEach(v => vertices.push(v.x, v.y, v.z));
            for (let i = 1; i < profile.length - 1; i++) indices.push(0, i, i + 1);
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();
            return geometry;
        }

        // --- DRAWING ---
        function updateSimulation() {
            while(meshGroup.children.length > 0) {
                const o = meshGroup.children[0];
                if(o.geometry) o.geometry.dispose();
                if(o.material) {
                    if(Array.isArray(o.material)) o.material.forEach(m=>m.dispose());
                    else o.material.dispose();
                }
                meshGroup.remove(o);
            }
            while(lineGroup.children.length > 0) lineGroup.remove(lineGroup.children[0]);
            while(axesGroup.children.length > 0) axesGroup.remove(axesGroup.children[0]);

            const data = getCurvePoints();
            if (!data) return;
            const { points, maxVal, maxDim } = data;

            let maxH = 0;
            if (config.sliceShape === 'equilateral') maxH = maxVal * Math.sqrt(3);
            else if (config.sliceShape === 'square') maxH = maxVal * 2;
            else if (config.sliceShape === 'semicircle') maxH = maxVal;
            else if (config.sliceShape === 'isosceles') maxH = maxVal * 2;
            
            const maxXExtent = Math.max(Math.abs(config.a), Math.abs(config.b));
            const maxYExtent = maxVal;
            
            drawAxes(maxXExtent * 1.3, maxYExtent * 1.3, maxH * 1.1);

            const lineGeom = new THREE.BufferGeometry().setFromPoints(points.map(p => new THREE.Vector3(p.x, p.y, 0)));
            const lineMat = new THREE.LineBasicMaterial({ color: 0xf59e0b, linewidth: 2 });
            lineGroup.add(new THREE.Line(lineGeom, lineMat));
            
            const lineGeom2 = new THREE.BufferGeometry().setFromPoints(points.map(p => new THREE.Vector3(p.x, -p.y, 0)));
            lineGroup.add(new THREE.Line(lineGeom2, lineMat));

            const solidGeo = createSlicedGeometry(points, config.currentX);

            const solidMat = new THREE.MeshPhysicalMaterial({
                color: config.color,
                metalness: 0.1, 
                roughness: 0.2,
                transparent: true, 
                opacity: config.opacity,
                side: THREE.DoubleSide,
                depthWrite: false, 
                polygonOffset: true,
                polygonOffsetFactor: 1, 
                polygonOffsetUnits: 1
            });
            const solid = new THREE.Mesh(solidGeo, solidMat);
            solid.castShadow = true;
            solid.receiveShadow = true;
            meshGroup.add(solid);

            if (config.wireframe) {
                const wireMat = new THREE.MeshBasicMaterial({
                    color: 0x1e3a8a, 
                    wireframe: true,
                    transparent: true,
                    opacity: 0.5 
                });
                const wireMesh = new THREE.Mesh(solidGeo, wireMat);
                meshGroup.add(wireMesh);
            }

            let currentY = 0;
            let idx = 0;
            while(idx < points.length && points[idx].x < config.currentX) idx++;
            if (idx < points.length && idx > 0) {
                const p1 = points[idx-1]; const p2 = points[idx];
                const t = (config.currentX - p1.x) / (p2.x - p1.x);
                currentY = p1.y + (p2.y - p1.y) * t;
            } else if (idx === 0) { currentY = points[0].y; } 
            else { currentY = points[points.length-1].y; }
            
            const sliceGeo = createCurrentSliceMesh(config.currentX, currentY);
            if(sliceGeo) {
                const sliceMat = new THREE.MeshPhysicalMaterial({ 
                    color: 0xffc107, 
                    side: THREE.DoubleSide, 
                    transparent: true, 
                    opacity: 0.7,
                    metalness: 0.1,
                    roughness: 0.1,
                    clearcoat: 0.8,
                    emissive: 0xff8f00, 
                    emissiveIntensity: 0.3
                });
                const slice = new THREE.Mesh(sliceGeo, sliceMat);
                slice.position.x += 0.002; 
                meshGroup.add(slice);
                
                const edges = new THREE.EdgesGeometry(sliceGeo);
                const outline = new THREE.LineSegments(edges, new THREE.LineBasicMaterial( { color: 0xb45309, linewidth: 2 } ) ); 
                outline.position.x += 0.003;
                meshGroup.add(outline);
            }
        }

        function makeTextSprite(message, parameters) {
            if ( parameters === undefined ) parameters = {};
            var fontsize = parameters.hasOwnProperty("fontsize") ? parameters["fontsize"] : 50;
            var canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 64;
            var context = canvas.getContext('2d');
            
            context.clearRect(0, 0, canvas.width, canvas.height);

            context.font = "Italic bold " + fontsize + "px 'Times New Roman', serif";
            context.fillStyle = "rgba(51, 65, 85, 1.0)"; 
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText( message, canvas.width/2, canvas.height/2);
            
            var texture = new THREE.Texture(canvas); 
            texture.needsUpdate = true;
            
            var spriteMaterial = new THREE.SpriteMaterial( { map: texture, transparent: true, depthTest: false } );
            var sprite = new THREE.Sprite( spriteMaterial );
            sprite.scale.set(1.5, 0.75, 1.0); 
            sprite.renderOrder = 999;
            return sprite;
        }

        function drawAxes(xLen, yLen, zLen) {
            function axis(color, dir, label, size) {
                const g = new THREE.Group();
                const mat = new THREE.MeshBasicMaterial({color});
                
                const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, size, 8), mat);
                shaft.position.y = size/2;
                const head = new THREE.Mesh(new THREE.ConeGeometry(0.15, 0.3, 12), mat);
                head.position.y = size;
                g.add(shaft, head);

                const negGeo = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, -size, 0)
                ]);
                const negMat = new THREE.LineDashedMaterial({
                    color: color,
                    dashSize: 0.3,
                    gapSize: 0.2,
                    opacity: 0.4,
                    transparent: true
                });
                const negLine = new THREE.Line(negGeo, negMat);
                negLine.computeLineDistances(); 
                g.add(negLine);
                
                if(dir==='x') g.rotation.z = -Math.PI/2;
                if(dir==='z') g.rotation.x = Math.PI/2;
                axesGroup.add(g);

                const sprite = makeTextSprite(label, { fontsize: 40 });
                const labelPos = size + 0.6;
                if(dir==='x') sprite.position.set(labelPos, 0, 0);
                if(dir==='y') sprite.position.set(0, labelPos, 0);
                if(dir==='z') sprite.position.set(0, 0, labelPos);
                axesGroup.add(sprite);
            }
            axis(0xef4444, 'x', 'x', xLen); 
            axis(0x22c55e, 'y', 'y', yLen); 
            axis(0x3b82f6, 'z', 'z', zLen);

            const originSprite = makeTextSprite('O', { fontsize: 40 });
            originSprite.position.set(-0.5, -0.5, 0);
            axesGroup.add(originSprite);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            if (isPlaying) {
                let nextX = parseFloat(config.currentX) + 0.05;
                if (nextX >= config.b) {
                    nextX = config.b;
                    isPlaying = false;
                    updatePlayButtons(); 
                }
                config.currentX = nextX;
                sliceXSlider.value = nextX;
                sliceXVal.innerText = nextX.toFixed(2);
                updateSimulation(); 
            }
            renderer.render(scene, camera);
        }

        function debounce(func, timeout = 500){
            return (...args) => {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => { func.apply(this, args); }, timeout);
            };
        }

        const autoUpdate = debounce(() => {
            updateUI();
        }, 500);

        function updateUI() {
            config.expr = inputFunc.value;
            config.a = parseFloat(inputA.value);
            config.b = parseFloat(inputB.value);
            config.sliceShape = shapeSelect.value;
            config.wireframe = wireframeCheck.checked;
            config.opacity = parseFloat(opacitySlider.value);
            
            const sliderVal = parseFloat(sliceXSlider.value);
            if(!isPlaying) {
                config.currentX = sliderVal;
                sliceXVal.innerText = sliderVal.toFixed(2);
            }
            updateSimulation();
        }

        inputFunc.addEventListener('input', autoUpdate);
        inputA.addEventListener('input', autoUpdate);
        inputB.addEventListener('input', autoUpdate);
        
        shapeSelect.addEventListener('change', updateUI);
        sliceXSlider.addEventListener('input', updateUI);
        wireframeCheck.addEventListener('change', updateUI);
        opacitySlider.addEventListener('input', () => {
             document.getElementById('opacityVal').innerText = (opacitySlider.value * 100).toFixed(0) + '%';
             updateUI();
        });

        // Toggle Play Logic
        function togglePlay() {
            if (!isPlaying && config.currentX >= config.b) {
                config.currentX = config.a;
                sliceXSlider.value = config.a;
            }
            isPlaying = !isPlaying;
            updatePlayButtons();
        }

        function updatePlayButtons() {
            const html = isPlaying 
                ? '<i class="fa-solid fa-pause"></i> <span id="fabPlayText">DỪNG</span>' 
                : '<i class="fa-solid fa-play"></i> <span id="fabPlayText">CHẠY</span>';
            fabPlayBtn.innerHTML = html;
        }

        fabPlayBtn.addEventListener('click', togglePlay);
        
        // Reset Camera Logic
        fabResetBtn.addEventListener('click', () => {
             controls.reset(); 
             camera.position.set(12, -12, 10); 
        });

        // Sidebar Toggle Logic
        const sidebar = document.getElementById('sidebar');
        const overlay = document.getElementById('sidebarOverlay');
        const closeSidebarBtn = document.getElementById('closeSidebarBtn');

        function toggleSidebar() {
            // Mobile toggle
            if (window.innerWidth < 768) {
                const isHidden = sidebar.classList.contains('-translate-x-full');
                if(isHidden) {
                    sidebar.classList.remove('-translate-x-full');
                    overlay.classList.remove('hidden');
                } else {
                    sidebar.classList.add('-translate-x-full');
                    overlay.classList.add('hidden');
                }
            } else {
                // Desktop toggle (using negative margin)
                sidebar.classList.toggle('md:-ml-80');
            }
        }

        fabMenuBtn.addEventListener('click', toggleSidebar);
        closeSidebarBtn.addEventListener('click', toggleSidebar);
        overlay.addEventListener('click', toggleSidebar);
        desktopToggleBtn.addEventListener('click', toggleSidebar);

        init();

    </script>
</body>
</html>
